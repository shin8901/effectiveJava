# 변경가능성을 최소화 하라

**불변 클래스** : 인스턴스의 내부값을 수정 할 수 없는 클래스

간직된 정보는 객체가 파괴될 때 까지 들고있으..

String, 기본타입의 박싱 클래스들, BigInteger..

**불변클래스의 핵심**
*	객체의 상태를 변경하는 메서드를 제공하지않는다.		
*	클래스를 확장 할 수 없도록한다.
*	모든 필드를 final로 선언한다.
*	모든 필드를 private으로 선언한다.
*	자신 외에는 내부의 가변 컴포넌트에 접근 할 수 없도록 한다.
	

 
```java
	public final class Complex {

		private final double re;
		private final double im;
	
		public Complex(double re, double im) {
			this.re = re;
			this.im = im;
		}
	
		public double realPart() {
			return re;
		}
	
		public double imaginaryPart() {
			return im;
		}
	
		public Complex plus(Complex c) {
			return new Complex(re + c.re, im + c.im);
		}
		
		
	}
```

**사칙연산 메소드들이 값을 바꾸지않고, 새로운 객체를 반환하는 것에 주목.** 
 피연산자가 그대로인것 함수형 프로그래밍.

	
**불변이 되는 영역의 비율이 높아지는 장점.** 
> 프로그래머가 다른 노력을 들이지 않아도 불변이 됨으로써, 가변객체가 가지는 불확실성, 임의의 복잡한 상태에서 벗어 날 수 있음.
> 변경자 메서드가 일으키는 상태 전이를 정밀하게 문서로 남겨놓지 않으면, 사용하기 굉장히 까다로움.

	
불변 객체는 근본적으로 Thread safe , 동기화에 대한 걱정을 덜 수 있다. -> 클래스를 가장 간단하게 Thread safe하게 만드는 방법.

불변 객체는 안심하고 공유가능. 인스턴스를 재사용 하는것을 권장.


Complex 클래스가 제공 할 수 있는 상수들


```java
	public static final Complex ZERO = new Complex(0,0);
	public static final Complex ONE = new Complex(1,0);
```


정적 팩토리 (item 1)를 제공할 수 있어, 여러 클라이언트가 한 인스턴스를 볼 수 있도록 처리가능.
> 이는 가비지 컬렉션 비용을 줄일 수 있고, 메모리 사용량을 줄 일 수 있다.

새로운 클래스를 설계할때, 정적 팩토리를 만들어두면, 클라이언트를 수정하지 않는 선에서, 캐싱기능을 덧붙일수 있음.

불변 객체는 자유롭게 공유가능, 불변객체끼리 내부 데이터 공유가능.


**객체를 만들때 다른 불변객체들을 구성요소로 사용하면 이점이 많다.**
> 값이 바뀌지않는 구성요소(불변요소)들로 이뤄진 객체라면, 구조가 복잡하더라도 불변식을 유지하기 쉬움.
> 예) 맵,Set 의 원소로 사용. -> 담긴값이 바뀌면 불변식이 허물어짐. 불변객체를 사용하면 그럴일 없음.

 
**불변객체는 그 자체로 실패 원자성을 제공함**
> 바뀔일이 없으니 유지됨.
> (실패 원자성) :  메서드에서 예외가 발생한 후에도, 그 객체는 여전히 (메소드 호출 전과 똑같은 ) 유효한 상황이어야 한다.

	
 
**불변의 단점**
> 객체가 바뀌지 않으니, 값이 다른 객체를 사용하려면, 객체를 만들어야함.
> BigInteger의 경우, 백만비트중에 1만 달라도 다른객체를 사용해야하니, 사용하지 않고 버려진다면 성능상 문제등등이 붉어 질 수 있음.

> 이경우에 2가지 대처방안이 있는데
> 1. 다단계 연산을 예측하여 기본기능으로 제공하는것. package-private 가변동반클래스
>> 다단연산을 기본으로 제공하여, 연산 단계마다 새로운 객체를 사용하지 않아도 되도록 만들기.
>> BigInteger의 경우 다단연산을 도와주는 가변동반 클래스를 package-private(default)로 가지고있다.
>> BigInteger를 사용하는것보다 가변동반클래스를 이용하는것이 훨씬 어렵지만, BigInteger의 메소드로 가변 동반클래스를 이용 할 수 있으니 다행.

> 2. 가변동반클래스를 public 으로 제공.
>> 대표적인 예가 String - StringBuilder(혹은 StringBuffer)


**불변으로 만들기 위해서 하는것들**
> 클래스가 불변임을 보장하려면, 자신을 상속하지 못하도록 해야하는데, 
> class를 final로 선언하는 방법도 있지만, 더 유연한것은 생성자를 private으로 만들고, 정적 팩터리 메소드를 제공하는것.
> 생성자를 private으로 만들면 일반적으로는 생성자를 이용해서, 객체를 생성할 수 없으모로 ㅇㅋ?
 
**BigInteger,BigDecimal 사용에 유의**
> 설계 당시 불변 객체가 사실상 final 이어야 한다는 개념이 없었.
> 이 두 클래스의 메소드들은 재정의 될 수 있도록 설계됨.
> 하위 호환성이 발목을 잡아, 지금까지 이문제를 해결하지 못함.
> ---> 신뢰할 수 없는 클라이언트에게 이 객체를 받아서 사용한다면, 진짜 'BigInteger' or 'BigDecimal' 인지 확인할 필요가 있음.
> 신뢰할 수 없다고 판단되면, 인수는 가변이라고 가정하고, 방어적으로 복사해야함.

```java
	public static BigInteger safeInstance(BigInteger val){
		return val.getClass == BigInteger.class ? val : new BigInteger(val.toByteArray());
	}
```

**모든 필드는 final 이어야 한다 ??**
> **어떤 메서드도 객체의 상태 중 외부에 비치는 값을 변경할 수 없다**
> 정도로 변경가능.
> 계산 비용이 큰 값들은 계산해놨다가 (가변 변수에 저장), 캐싱하여 돌려주기도 함.


 
#핵심정리





